## Алгоритм подсчета рейтинга

Алгоритм подсчета рейтинга носит синтетический характер и его главным назначением является динамический подсчет рейтинга сервиса ноды  с одновременной компенсацией этого значения по техническим и информационным показателям.

Величина функции является безразмерной и имеет физический смысл как относительная доля вклада конкретной ноды в суммарный рейтинг нод сети. Расчет непрерывной функции значения рейтинга ноды $R$ в момент времени $t - R(t)$ затруднен тем, что текущего его значения в дискретной системе отсчета не существует. Т.е., можно говорить, что значение функции верно в моменты времени, совпадающие с изменениями в системе - в сети нод, т.е. $t_{-n}, t_{0}...t_{\infty}$. В данной методике на основе анализа показателей, от которых зависит значение функции в дискретные моменты на выбранном историческом периоде и предположения о существовании зависимости суммарного рейтинга сети от рыночных настроений, делается предположение о возможности кратковременного полиномиального прогнозирования его значения   на основе статистических сетевых данных.

В каждый период отсчета работы сети, значение рейтинга ноды зависит от нескольких параметров:

*1. Относительного вклада мощности ноды в суммарную мощность сети.*

Здесь стоит упомянуть тот факт, что большинство алгоритмов информационного обмена и верификации данных в распределенной сети предусматривает равноправное участие её активных членов в этом процессе.   Посему **_мощность_**  конкретной ноды, как полноценного участника, влияет на среднее время обработки информации. Её относительное значение зависит от суммарной вычислительной мощности сети -  $P$  , которую можно представить, как сумму дискретных значений мощности нод сети:

$$P=\sum\limits_{i=0}^MP_{i}(T=t_{j})\tag{1.1}$$

Где $M$   количество нод в сети, $P_{i}$ вычислительная мощность $i$- ой ноды в дискретный момент $T$ - из $j$-го события.

При этом **_относительный вклад мощности ноды_** в суммарную вычислительную мощность сети выглядит как:

$$P_{0}=\frac{P_{i}(T=t_{j})}{P}\tag{1.2}$$

**Примечание:** *Очевидно, что увеличение суммарной мощности сети нод при постоянном её значении у конкретной ноды приводит к уменьшению значения её относительного веса в системе, что необходимо учесть при  учете влияния на результирующий показатель.*

*2.  Относительной скорости работы сети.*

Величина $V_{N}$ которая определяется количеством подтвержденных пакетов передачи данных за единицу времени в сети, в которой работает нода, очевидно, будет влиять на её рейтинг. Памятуя о том, что результатом данной методики является величина относительная, целесообразно пронормировать данный показатель Vo либо к среднему его значению по сети, либо к максимальному значению. Данный выбор можно сделать экспериментальным путем, при вычислении уровня неопределенности значения функции рейтинга ноды.


*3. Относительного вклада ноды в информационный обмен - активности.*

Относительная доля вклада конкретной ноды в информационный обмен Ko характеризует её активность. Он зависит от суммарного значения объема информационного обмена - количества единиц информации  $K$, передаваемой в распределенной сети за интервал времени активными участниками сети, подсчитанного статистически, и объема вклада $K_{i}$ -ой ноды в этот обмен.

Здесь следует заметить, что существенное влияние на данный показатель оказывают 1 и 2 из упомянутых выше, что позволяет предположить его интегральную природу. То-есть, его значение в дискретный период времени $j$ го события есть величина площади фигуры, ограниченной функцией изменения суммарного информационного обмена за период времени $\Delta{t}$  в зависимости от скорости изменения вклада $i$ -ой ой ноды, которая определяется производной от функций изменения относительных величин 1 и 2:

![Screenshot](_images/3n.png)
(1.3)



$$ K_{0}=\frac{K_{i}}{K}\int\limits_{t_{j-1}}^{t_{j}}\frac{V_{0}(t)+P_{0}(t)dt}{2}\tag{1.4}$$


При рассмотрении графика зависимости можно предположить,  что бесконечно увеличение мощности ноды не повлечет за собой бесконечного роста относительной доли вклада и закономерность её распределения, например, при полиномиальном прогнозе, будет иметь экспоненциальный характер, что можно будет использовать для компенсации его влияния на распределение, учитывая вес следующих показателей.

*4.  Суммы ставок.*

Учитывая одно из основных требований peer-to-peer сети, которое исключает рост доминирования её отдельных членов в оперативном обмене информацией, с целью предотвращения её централизации данный показатель можно использовать как  **компенсирующий** influence of technical indicators 1, 2 and 3. Предваряя описание, суть подхода в том, что расчет рейтинга ноды в момент времени $t$ производится расчетом среднего значения натурального логарифма от относительной суммы ставок и  логарифмически обратной функции от значения относительного вклада ноды в информационный обмен.  То-есть приведенная сумма ставок $S$ за время $j$-го периода событий логарифмически инверсна относительному вкладу в информационный обмен.

Данная зависимость демонстрирует компенсационную взвешенность подсчета рейтинга нод из абсолютно разных “весовых” категорий.  То-есть, при максимально возможном увеличении вычислительных ресурсов, качества сети и активности и при таких же максимальных суммах ставок, рейтинг ноды останется не более чем на среднем уровне. При других определенных значениях, возможны более высокие или более низкие рейтинги, не противоречащие логике.
Таким образом

$$S_{0}={S_i(T=t_{i})}/{\sum\limits_{i_{0}}^{N}S_{i}}\tag{1.5}$$

Где $S_{i}$- сумма ставок $i$-ой ноды за время события $j$, $S_{0}$- приведенное значение суммы ставок $i$-й ноды за время события $j$. 

**Примечание:** *Уместно будет пояснить, что время события j есть интервал времени от последнего события в сети, при котором были получены последние значения необходимых в данной методике показателей.*

*5. Достоверности исторической информации, то-есть “слухов”*

В системах с распределенным подтверждением транзакций, для реализации большинства алгоритмов консенсуса, используется информация о прошлых событиях в сети. Но учитывая тот факт, что далеко не все ноды могут физически находится в сети, в их блокчейнах формируются пробелы, в силу чего остальные ноды, при запросе о восстановлении своих недостающих данных при вычислении алгоритма консенсуса, вынуждены впустую тратить вычислительный ресурс на запрос у них несуществующих данных. Чтобы снизить вероятность такого исхода и тем самым сохранить скоростные показатели обмена в сети на требуемом уровне, необходимо включить в расчет рейтинга приведенную достоверность информации $I_{0}$ как отношение количества пробелов в блокчейне с общим объемом единиц информации    в нем. В **_отличии от показателя 3_**, данный показатель формируется не относительно всей сети, а о собственных ресурсах ноды. 

Формально, его можно учесть как весовой мультипликативный коэффициент при расчете окончательного рейтинга ноды.

**Описание методики**

С учетом приведенных показателей и исходя из гипотезы, первый этап расчета рейтинга  в момент времени t за время действия события j выглядит следующим образом:

$$R_{j}=I_{0}(\ln{S_{0}+\ln{K_{0}/(K_{0}-1)}})/2\tag{1.6}$$

На данном этапе, как уже сказано,  мы получаем дискретное значение рейтинга за время события $j$.
Уточненная же задача методики состоит в том, чтобы иметь с высокой вероятность достоверное значение рейтинга в заданный непрерывный период $\Delta{t}$  с момента окончания события $j$ .

Для наглядности построим графики относительный зависимостей, изложенных выше. 

![Screenshot](_images/4.jpg)
 
На рисунке наглядно представлена зависимость относительной величины рейтинга ноды относительно других в сети, которая отсчитывается по оси ординат от точки пересечения графиков двух функций:  $K$, характеризующей относительную техническую оснащенность сервиса, его сетевые параметры, хеш рейт и ping time, и $S$ - относительный баланс. Значение рейтинга максимально в точке пересечения, т.е  при достижении баланса двух показателей, т.е. Их взаимной компенсации. Другими словами - повысить свой рейтинг максимально скупив все токены или создав супермощный пул вычислительных мощностей невозможно, рейтинг будет компенсирован. В теории это возможно, но это при наличии одного сервиса ноды в сети.

Если изобразить графики по другому

![Screenshot](_images/5.jpg)
 
можно увидеть среднее отсчет значения рейтинга как среднее значение показателей $K$ и $S$ на синтетической кривой из значений. 
(Исходный приложение для демонстрации работы алгоритма можно скачать из репозитория GitHub по сслылке - https://github.com/evenfound/even-network/tree/master/r-score-demo).

## Краткое описание алгоритма PoS<sup>n</sup> 

> Для того чтобы подробно описать описать все детали и математику  метода нужно больше места. 
> Пока ограничимся кратким анонсом для понимания сути процесса.


Для поддержания целостности данных распределенного блокчейна и реализации алгоритма консенсуса необходимо создавать связный граф транзакций. Для этого _нода_ связывает каждую транзакцию с ,блокчейном с помощью ссылок: 
*   с одной стороны: на адрес IPFS своей  последней транзакции, которая в свою очередь связана с предыдущей, 
*   и с другой:  с адресом IPFS пакетов - (иx может быть несколько), которые прислали другие ноды, нуждающиеся в   валидации своих транзакций в приватном разделе файловой системы INBOX. 

На выходе мы получаем логическую структуру в виде графа. Данная форма не реляционного представления данных носит название DAG (направленный ациклический граф). Вершины его или узлы всегда “моложе” тех, на которые он ссылается.

Кроме эффектной архитектуры данных мы получаем возможность валидировать наши исторические данные при подсчете баланса, что так необходимо при подсчете баланса и отправке транзакций. 

Ключевым игроком здесь является связь с  соседней веткой, или branch транзакцией, которую нужно валидировать, чтобы создать свою.  Данная транзакция тоже в свою очередь содержит такие же ссылки. 

Валидация brunch позволяет достигнуть нескольких целей:
*   Проверяет ее на наличие возможного мошенничества сравнением балансов в дереве,
*   Делает намерения ноды валидатора известными сети и повышает его рейтинг.

На словах алгоритм можно описать так:
*   Нода начинает итеративно подсчитывать операционный баланс по счету branch транзакции по ее trunk ссылкам, используя скорости IPLD,
*   Одновременно с каждым шагом, она проверяет наличие в своей цепи trunk наличие адреса транзакции, совпадающего с текущим шагом в brunch,
*   Как только адреса и их операционные балансы совпадут - валидация успешна, и в качестве доказательства вместе с адресом branch в транзакции, указывается адрес транзакции, на которой валидация произошла. 
*   Если совпадения нет до генезиса, то скорее всего транзакция мошенническая и ссылка на нее удаляется из INBOX, не валидируется и не используется для собственной  валидации.

Теперь, после публикации, модуль кошелька любой ноды может проверить баланс входящей транзакции не только по отправителю но и по его валидациям. Опыт аналогичных систем хранения (IOTA, например) показал, что ближайшее совпадение происходит не далее 15-ой итерации.

## Пороговая подпись ECDSA с гомоморфным шифрованием

Гомоморфное шифрование позволяет производить операции над шифротекстами таким образом, что результат шифрования операций над ними будет равен результату операций над их шифрами. Это можно так проиллюстрировать:

$$ab_1=E(a)+eE(b)$$
$$ab_2=E(a+b)$$
$$D(ab_1)=D(ab_2)$$

Таким образом, мы можем иметь два значения - $а$ и $b$ . Сначала мы можем зашифровать эти значения, а затем, используя эту специальную операцию, добавить эти два шифротекста вместе. Или мы можем сначала, имея эти два значения, сложить их вместе, а затем зашифровать результат. Когда мы расшифруем, мы получим одно и то же значение в обоих случаях. 
Одним из примеров аддитивно-гомоморфной схемы шифрования является $Paili$, для которой существует эффективно вычисляемая операция «добавить», так что операция сложения это плюс с индексом e в первой формуле, который позволяет добавлять два шифротекста вместе.

Следующее - это $(t, n)$ пороговое шифрование. Самый простой способ объяснить это - сказать, что:
* у нас есть n игроков; 
* каждый из них имеет один и тот же открытый ключ, но каждый игрок имеет свою уникальную долю секретного ключа. 

Схема обязательств- на примере:
> Например, скажем, что Алиса и Кэролайн играют в игру с монетами. Алиса выбирает сторону монеты, шифрует свой выбор и отправляет обязательства Кэролайн. Теперь Кэролайн подбрасывает монету в воздух и говорит, каков результат. Затем Алиса отправляет специальное значение, называемое ключом разложения, которое позволяет Кэролайн оценить обязательство и посмотреть, действительно ли значение, которое изначально было выбрано Алисой, действительно соответствует ее словам.
Ключ обязательства позволяет его подтвердить, но также имеет приятную особенность, позволяющую безоговорочно определять схемы сокрытия. Таким образом, независимо от того, что делает Кэролайн, независимо от того, насколько высока ее вычислительная мощность, она не может угадать значение, которое Алиса взяла на себя, не имея ключа декомпозиции. Она не может сделать это только из обязательства [cхема обязательства](https://ru.wikipedia.org/Схема_обязательства).

В криптографии, схема обязательств или битовая схема обязательств (англ. Commitment scheme) — это метод, позволяющий пользователю подтверждать какое-либо значение, которое не разглашается, то есть в случае разглашения этого значения благодаря этой схеме будет известно, что пользователь знал его на момент выдачи обязательства и что оно не изменилось. Работу данной схемы можно представить как две стадии:
* _«Commit»_ — посылку закрытой на ключ коробки (обязательство),
* _«Reveal»_ — более поздняя отправка ключа от коробки (значение).
 
#### _*Протокол генерации ключа для подписи*_.
 
У нас есть $n$ - подписывающих, каждый подписывающий инициализируется с помощью схемы аддитивного гомоморфного порогового шифрования, и это происходит на этапе настройки.
1. На первом этапе каждый игрок выбирает случайное целое число x , которое будет использоваться как доля секретного ключа этого игрока<br><br>$x_i\in Z_q\rightarrow y_i=x_iG$ и $[C_iD_i]=commitTo(y_i)$<br><br>$х$ не может быть больше, чем $q$  - количества эллиптических кривых, то есть количества точек на эллиптической кривой. Каждый игрок вычисляет $y$ как $g$ в степени $x$ . Это операция с эллиптической кривой, и, по сути, мы умножаем точку генератора кривой на $x$ . Это обозначение, которое вы часто найдете для групп, но поскольку эллиптическая кривая является группой, можно использовать ее и здесь. Затем каждый игрок вычисляет обязательство Ci для этого значения.  
2. Во втором раунде публикует обязательство  $C_i$ для всех игроков в группе. 
3. Затем, на третьем шаге, каждый игрок показывает x в зашифрованном виде $\alpha_i=E(x_i), y_i, D_i - ZKP(Zero-knowledge proof*)$ что означает: <br><br>$\exists x_i$ из $[q^{-3},q^{3}]$ так что $y_i=x_iG$ и $D(\alpha_i)=x_i$, где $q$ - мощность эллиптической кривой.<br><br>Шифрование выполняется с помощью аддитивно-гомоморфной схемы шифрования, которую инициализировали на этапе настройки. Более того, каждый игрок раскрывает общий доступ к открытому ключу, ключ к выводу из игры и доказательство отсутствия знаний $D_i$ о том, что все эти значения вместе имеют смысл. Это позволяет подтвердить обязательство $C_i$, но также позволяет всем игрокам увидеть, имеют ли смысл все те акции, которые игрок только что показал вместе.<br>Итак, доказательство с нулевым знанием говорит, что существует такое число $x_i$, что точка генератора кривой, умноженная на $x_i$, дает точку $y_i$, и $y_i$ является публичным в этот момент, потому что оно была только что обнаружена, и что если мы расшифруем значение $\alpha_i$ , то имеем только что опубликованный - это зашифрованный секретный ключ - мы получим это число $x_i$. <br>Конечно, это доказательство с нулевым знанием, поэтому невозможно угадать, что на самом деле представляет собой $x_i$, но здесь мы говорим о том, что он лежит в диапазоне от $[q^{-3},q^{3}]$ , и поскольку $q$ - это мощность эллиптической кривой, этот диапазон действительно огромен.
4. На четвертом шаге все подписывающие участники используют операцию добавления аддитивно-гомоморфной пороговой схемы для получения окончательного ключа t-ECDSA, поэтому можно добавить все зашифрованные доли $x_i$:<br><br>$\alpha=\alpha_1+e\alpha_2+e\alpha_3...+e\alpha_n = E(x_1)+E(x_2)+E(x_3)+...+E(x_n)$
$y= y_1+ y_2+ y_3+...+ y_n$<br><br>В результате мы получаем секретный ключ $\alpha$ в зашифрованном виде, все открытые общие доли y могут быть сложены - и в результате получаем открытый ключ. Операция сложения здесь - это просто сложение точек эллиптической кривой, так что это нечто простое.<br><br>$y - plaintext, t-ECDSA public key$
$\alpha=E(x), ciphertext, t-ECDSA private key$


#### _*Алгоритм генерации ключа для подписи*_

У нас есть $\alpha$, который является закрытым ключом $t-ECDSA$ в зашифрованном виде, совместно используемом всеми подписавшими, и у нас есть $y$, который является открытым ключом $t-ECDSA$  - это просто точка на эллиптической кривой.
 
1. В первом раунде каждый из участников вычисляет случайное целое число $p_i$:<br><br>$p\in Z+q$<br><br>Затем шифрует это значение с помощью аддитивно-гомоморфной схемы порогового шифрования:<br><br>$u_i=E(p_i)$<br><br>И умножает секретный ключ $ECDSA$  $\alpha$ на это случайное значение:<br><br>$v_i=p_i\alpha=E(p_i,x)$<br><br>Это возможно, потому что аддитивно-гомоморфная схема шифрования имеет операции не только сложения, но и умножения. 
2. Во втором раунде участники раскрывают все эти результаты вместе с доказательством нулевого знания, заявляя, что они имеют смысл и  объединяют выявленные акции вместе, используя операцию сложения, определяемую гомоморфной схемой шифрования:<br><br>$u=\sum\limits_{i=0}^Nu_i=E(p)$<br>$V=\sum\limits_{i=0}^Nv_i=E(px)$<br><br>Во втором раунде участники раскрывают все эти результаты вместе с доказательством нулевого знания, заявляя, что они имеют смысл и  объединяют выявленные акции вместе, используя операцию сложения, определяемую гомоморфной схемой шифрования. У участников есть все параметры, которые были вычислены до сих пор, и у всех игроков они одинаковы.
3. В третьем раунде каждый участник вычисляет случайное целое число $k_i$:<br><br>$k_i\in Z_q$<br><br>И случайное число $c_i$<br><br>$c_i\in [-q^6,q^6]$<br><br>$q$ все время обозначает мощность эллиптической кривой, то есть количество точек на эллиптической кривой.<br>Каждая сторона вычисляет $r_i$ как $g$ в степени $k$  -  но в нашем случае можно просто умножить точку генератора кривой на нее.<br><br>$r_i=g^{k_i}$<br><br>Каждый участник вычисляет параметр $w$, который равен $k$ раз $\rho$ плюс $c$ раз $q$:<br><br>$w_i=E(k_ip+c_iq)$<br><br>$q$ все время - мощность эллиптической кривой, и мы можем вычислить ее, потому что мы используем аддитивно гомоморфное пороговое шифрование.В конце, каждая сторона принимает все эти параметры.
4. В 4 раунде сгенерированные параметры раскрываются вместе с доказательством нулевого знания о том, что они имеют смысл вместе:<br><br>Представляет ZKP, доказывая, что значения $r_i$ и $w_i$ корректны.<br>Имея все эти параметры от всех участников группы, мы можем сложить их вместе, как это сделали в конце 2 раунда. Производится суммирование всех $k$ значений, всех $c$ значений, всех $w$ значений. Более того, мы оцениваем параметр $r$ как сумму всех долей $r_i$ и используем специальную хеш-функцию:<br><br>$k=\sum\limits_{i=0}^Nk_i$<br>$c=\sum\limits_{i=0}^Nc_i$<br>$w=\sum\limits_{i=0}^Nw_i=E(kp+cq)$<br>$r=h(\sum\limits_{i=0}^Nr_i)=H(g^k)$<br><br>На самом деле это та функция, которую мы знаем из стандартного протокола $ECDSA$: это координата точки $x$ по модулю эллиптической кривой. В конце раунда все параметры, перечисленные ниже, являются общими для всех подписавшихся в группе:<br><br>$u=\sum\limits_{i=0}^Nu_i=E(p)$, где $u_i \in Z_q$<br>$v=\sum\limits_{i=0}^Nv_i=E(px)$<br>$k=\sum\limits_{i=0}^Nk_i=E(p)$, где $k_i \in Z_q$<br>$w=\sum\limits_{i=0}^Nw_i=E(kp+cq)$<br>$r=H(\sum\limits_{i=0}^Nr_i)=H(g^k)$<br><br> 
5. Теперь необходимо сделать некоторые дискретные математические преобразования, чтобы создать подпись. Используя все эти параметры, которые до сих пор были получены. Поскольку мы работаем с зашифрованными данными, подпись также будет зашифрована.<br>Первое, что нужно сделать, - это запустить механизм расшифровки порога, чтобы все участники расшифровали параметр $w$ и присвоили это значение $\eta$:<br><br>$\eta=TDec(w)=kp mod q$ - все участники одновременно дешифруют $w$<br><br>Далее вычисляется параметр $\Psi$, который является мультипликативным обратным к $\eta$ по модулю $q$ , а $q$ - это мощность всего эллиптической кривой по времени:<br><br>$\Psi=n^{-1}mod q = k^{-1}p^{-1}$<br><br>Затем, имея $m$ , который является хэшем сообщения, которое мы подписываем (или хэш транзакции), производится оценка подписи с помощью следующего уравнения:<br><br>$\sigma=\Psi\times _e[(m\times _eu)+_eE(r\times_ev)]$<br><br>$c$ - значение, которое мы только что оценили, а $u$ , $r$ и $v$ - параметры, совместно оцененные всеми подписавшими сторонами в предыдущих раундах.<br>Итак, поскольку $u$ является зашифрованным $r$ , а $v$ является зашифрованным $ρ$, умноженным на секретный ключ $ECDSA$, мы можем выполнить следующее преобразование:<br><br>$\sigma=\psi\times_e[E(mp)+_eE(rpx)]$<br><br>И если мы заменим $\Psi$ значением, которое оно представляет, мы получим следующее уравнение:<br><br>$\sigma=(k^{-1}p^{-1})\times_e[E(mp)+eE(rpx)]$<br><br>И, наконец, если мы исключим $ρ$, мы получим это:<br><br>$\sigma=E(k^{-1}(m+xr))$<br><br>А это есть ни что иное, как уравнение для стандартной сигнатуры $ECDSA$, где $k$- криптографически безопасное случайное целое число, $m$ - хеш сообщения, $x$ - наш секретный ключ $ECDSA$, а $r$ - точка, сгенерированная кривой умноженное в $k$ раз по модулю $q$. Так что это уравнение для стандартного протокола $ECDSA$.<br>Так как все уравнения были сделаны на шифротекстах, то и результирующая подпись будет зашифрована:<br><br>$\sigma=E(s)$<br><br> 
6. Теперь необходимо использовать механизм расшифровки пароля, чтобы узнать значение $s$. И расшифрованное значение $s$ и полученное в 4 раунде значение $r$, вместе составляют подпись.