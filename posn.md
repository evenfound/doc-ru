## Краткое описание алгоритма PoS<sup>n</sup> 

> Для того чтобы подробно описать описать все детали и математику  метода нужно больше места. 
> Пока ограничимся кратким анонсом для понимания сути процесса.


Для поддержания целостности данных распределенного блокчейна и реализации алгоритма консенсуса необходимо создавать связный граф транзакций. Для этого _нода_ связывает каждую транзакцию с ,блокчейном с помощью ссылок: 
*   с одной стороны: на адрес IPFS своей  последней транзакции, которая в свою очередь связана с предыдущей, 
*   и с другой:  с адресом IPFS пакетов - (иx может быть несколько), которые прислали другие ноды, нуждающиеся в   валидации своих транзакций в приватном разделе файловой системы INBOX. 

На выходе мы получаем логическую структуру в виде графа. Данная форма не реляционного представления данных носит название DAG (направленный ациклический граф). Вершины его или узлы всегда “моложе” тех, на которые он ссылается.

Кроме эффектной архитектуры данных мы получаем возможность валидировать наши исторические данные при подсчете баланса, что так необходимо при подсчете баланса и отправке транзакций. 

Ключевым игроком здесь является связь с  соседней веткой, или branch транзакцией, которую нужно валидировать, чтобы создать свою.  Данная транзакция тоже в свою очередь содержит такие же ссылки. 

Валидация brunch позволяет достигнуть нескольких целей:
*   Проверяет ее на наличие возможного мошенничества сравнением балансов в дереве,
*   Делает намерения ноды валидатора известными сети и повышает его рейтинг.

На словах алгоритм можно описать так:
*   Нода начинает итеративно подсчитывать операционный баланс по счету branch транзакции по ее trunk ссылкам, используя скорости IPLD,
*   Одновременно с каждым шагом, она проверяет наличие в своей цепи trunk наличие адреса транзакции, совпадающего с текущим шагом в brunch,
*   Как только адреса и их операционные балансы совпадут - валидация успешна, и в качестве доказательства вместе с адресом branch в транзакции, указывается адрес транзакции, на которой валидация произошла. 
*   Если совпадения нет до генезиса, то скорее всего транзакция мошенническая и ссылка на нее удаляется из INBOX, не валидируется и не используется для собственной  валидации.

Теперь, после публикации, модуль кошелька любой ноды может проверить баланс входящей транзакции не только по отправителю но и по его валидациям. Опыт аналогичных систем хранения (IOTA, например) показал, что ближайшее совпадение происходит не далее 15-ой итерации.

## Пороговая подпись ECDSA с гомоморфным шифрованием

Гомоморфное шифрование позволяет производить операции над шифротекстами таким образом, что результат шифрования операций над ними будет равен результату операций над их шифрами. Это можно так проиллюстрировать:

$$ab_1=E(a)+eE(b)$$
$$ab_2=E(a+b)$$
$$D(ab_1)=D(ab_2)$$

Таким образом, мы можем иметь два значения - $а$ и $b$ . Сначала мы можем зашифровать эти значения, а затем, используя эту специальную операцию, добавить эти два шифротекста вместе. Или мы можем сначала, имея эти два значения, сложить их вместе, а затем зашифровать результат. Когда мы расшифруем, мы получим одно и то же значение в обоих случаях. 
Одним из примеров аддитивно-гомоморфной схемы шифрования является $Paili$, для которой существует эффективно вычисляемая операция «добавить», так что операция сложения это плюс с индексом e в первой формуле, который позволяет добавлять два шифротекста вместе.

Следующее - это $(t, n)$ пороговое шифрование. Самый простой способ объяснить это - сказать, что:
* у нас есть n игроков; 
* каждый из них имеет один и тот же открытый ключ, но каждый игрок имеет свою уникальную долю секретного ключа. 

Схема обязательств- на примере:
> Например, скажем, что Алиса и Кэролайн играют в игру с монетами. Алиса выбирает сторону монеты, шифрует свой выбор и отправляет обязательства Кэролайн. Теперь Кэролайн подбрасывает монету в воздух и говорит, каков результат. Затем Алиса отправляет специальное значение, называемое ключом разложения, которое позволяет Кэролайн оценить обязательство и посмотреть, действительно ли значение, которое изначально было выбрано Алисой, действительно соответствует ее словам.
Ключ обязательства позволяет его подтвердить, но также имеет приятную особенность, позволяющую безоговорочно определять схемы сокрытия. Таким образом, независимо от того, что делает Кэролайн, независимо от того, насколько высока ее вычислительная мощность, она не может угадать значение, которое Алиса взяла на себя, не имея ключа декомпозиции. Она не может сделать это только из обязательства [cхема обязательства](https://ru.wikipedia.org/Схема_обязательства).

В криптографии, схема обязательств или битовая схема обязательств (англ. Commitment scheme) — это метод, позволяющий пользователю подтверждать какое-либо значение, которое не разглашается, то есть в случае разглашения этого значения благодаря этой схеме будет известно, что пользователь знал его на момент выдачи обязательства и что оно не изменилось. Работу данной схемы можно представить как две стадии:
* _«Commit»_ — посылку закрытой на ключ коробки (обязательство),
* _«Reveal»_ — более поздняя отправка ключа от коробки (значение).
 
####_Протокол генерации ключа для подписи_.
 
У нас есть $n$ - подписывающих, каждый подписывающий инициализируется с помощью схемы аддитивного гомоморфного порогового шифрования, и это происходит на этапе настройки.
1. На первом этапе каждый игрок выбирает случайное целое число x , которое будет использоваться как доля секретного ключа этого игрока<br><br>$x_i\in Z_q\rightarrow y_i=x_iG$ и $[C_iD_i]=commitTo(y_i)$<br><br>$х$ не может быть больше, чем $q$  - количества эллиптических кривых, то есть количества точек на эллиптической кривой. Каждый игрок вычисляет $y$ как $g$ в степени $x$ . Это операция с эллиптической кривой, и, по сути, мы умножаем точку генератора кривой на $x$ . Это обозначение, которое вы часто найдете для групп, но поскольку эллиптическая кривая является группой, можно использовать ее и здесь. Затем каждый игрок вычисляет обязательство Ci для этого значения.  
2. Во втором раунде публикует обязательство  $C_i$ для всех игроков в группе. 
3. Затем, на третьем шаге, каждый игрок показывает x в зашифрованном виде $\alpha_i=E(x_i), y_i, D_i - ZKP(Zero-knowledge proof*)$ что означает: <br><br>$\exists x_i$ из $[q^{-3},q^{3}]$ так что $y_i=x_iG$ и $D(\alpha_i)=x_i$, где $q$ - мощность эллиптической кривой.<br><br>Шифрование выполняется с помощью аддитивно-гомоморфной схемы шифрования, которую инициализировали на этапе настройки. Более того, каждый игрок раскрывает общий доступ к открытому ключу, ключ к выводу из игры и доказательство отсутствия знаний $D_i$ о том, что все эти значения вместе имеют смысл. Это позволяет подтвердить обязательство $C_i$, но также позволяет всем игрокам увидеть, имеют ли смысл все те акции, которые игрок только что показал вместе.<br>Итак, доказательство с нулевым знанием говорит, что существует такое число $x_i$, что точка генератора кривой, умноженная на $x_i$, дает точку $y_i$, и $y_i$ является публичным в этот момент, потому что оно была только что обнаружена, и что если мы расшифруем значение $\alpha_i$ , то имеем только что опубликованный - это зашифрованный секретный ключ - мы получим это число $x_i$. <br>Конечно, это доказательство с нулевым знанием, поэтому невозможно угадать, что на самом деле представляет собой $x_i$, но здесь мы говорим о том, что он лежит в диапазоне от $[q^{-3},q^{3}]$ , и поскольку $q$ - это мощность эллиптической кривой, этот диапазон действительно огромен.
4. На четвертом шаге все подписывающие участники используют операцию добавления аддитивно-гомоморфной пороговой схемы для получения окончательного ключа t-ECDSA, поэтому можно добавить все зашифрованные доли $x_i$:<br><br>$\alpha=\alpha_1+e\alpha_2+e\alpha_3...+e\alpha_n = E(x_1)+E(x_2)+E(x_3)+...+E(x_n)$
$y= y_1+ y_2+ y_3+...+ y_n$<br><br>В результате мы получаем секретный ключ $\alpha$ в зашифрованном виде, все открытые общие доли y могут быть сложены - и в результате получаем открытый ключ. Операция сложения здесь - это просто сложение точек эллиптической кривой, так что это нечто простое.<br><br>$y - plaintext, t-ECDSA public key$
$\alpha=E(x), ciphertext, t-ECDSA private key$


####_Алгоритм генерации ключа для подписи._

У нас есть $\alpha$, который является закрытым ключом $t-ECDSA$ в зашифрованном виде, совместно используемом всеми подписавшими, и у нас есть $y$, который является открытым ключом $t-ECDSA$  - это просто точка на эллиптической кривой.
 
1. В первом раунде каждый из участников вычисляет случайное целое число $p_i$:<br><br>$p\in Z+q$<br><br>Затем шифрует это значение с помощью аддитивно-гомоморфной схемы порогового шифрования:<br><br>$u_i=E(p_i)$<br><br>И умножает секретный ключ $ECDSA$  $\alpha$ на это случайное значение:<br><br>$v_i=p_i\alpha=E(p_i,x)$<br><br>Это возможно, потому что аддитивно-гомоморфная схема шифрования имеет операции не только сложения, но и умножения. 
2. Во втором раунде участники раскрывают все эти результаты вместе с доказательством нулевого знания, заявляя, что они имеют смысл и  объединяют выявленные акции вместе, используя операцию сложения, определяемую гомоморфной схемой шифрования:<br><br>$u=\sum\limits_{i=0}^Nu_i=E(p)$<br>$V=\sum\limits_{i=0}^Nv_i=E(px)$<br><br>Во втором раунде участники раскрывают все эти результаты вместе с доказательством нулевого знания, заявляя, что они имеют смысл и  объединяют выявленные акции вместе, используя операцию сложения, определяемую гомоморфной схемой шифрования. У участников есть все параметры, которые были вычислены до сих пор, и у всех игроков они одинаковы.
3. В третьем раунде каждый участник вычисляет случайное целое число $k_i$:<br><br>$k_i\in Z_q$<br><br>И случайное число $c_i$<br><br>$c_i\in [-q^6,q^6]$<br><br>$q$ все время обозначает мощность эллиптической кривой, то есть количество точек на эллиптической кривой.<br>Каждая сторона вычисляет $r_i$ как $g$ в степени $k$  -  но в нашем случае можно просто умножить точку генератора кривой на нее.<br><br>$r_i=g^{k_i}$<br><br>Каждый участник вычисляет параметр $w$, который равен $k$ раз $\rho$ плюс $c$ раз $q$:
 
$w_i=E(k_ip+c_iq)$
 
$q$ все время - мощность эллиптической кривой, и мы можем вычислить ее, потому что мы используем аддитивно гомоморфное пороговое шифрование.
В конце, каждая сторона принимает все эти параметры.

 

4. В 4 раунде сгенерированные параметры раскрываются вместе с доказательством нулевого знания о том, что они имеют смысл вместе:
 
Представляет ZKP, доказывая, что значения $r_i$ и $w_i$ корректны.
 
Имея все эти параметры от всех участников группы, мы можем сложить их вместе, как это сделали в конце 2 раунда. Производится суммирование всех $k$ значений, всех $c$ значений, всех $w$ значений. Более того, мы оцениваем параметр $r$ как сумму всех долей $r_i$ и используем специальную хеш-функцию:
 
$k=\sum\limits_{i=0}^Nk_i$
$c=\sum\limits_{i=0}^Nc_i$
$w=\sum\limits_{i=0}^Nw_i=E(kp+cq)$
$r=h(\sum\limits_{i=0}^Nr_i)=H(g^k)$
 
На самом деле это та функция, которую мы знаем из стандартного протокола $ECDSA$: это координата точки $x$ по модулю эллиптической кривой.
В конце раунда все параметры, перечисленные ниже, являются общими для всех подписавшихся в группе:
 
$u=\sum\limits_{i=0}^Nu_i=E(p)$, где $u_i \in Z_q$
$v=\sum\limits_{i=0}^Nv_i=E(px)$
$k=\sum\limits_{i=0}^Nk_i=E(p)$, где $k_i \in Z_q$
$w=\sum\limits_{i=0}^Nw_i=E(kp+cq)$
$r=H(\sum\limits_{i=0}^Nr_i)=H(g^k)$

 

5. Теперь необходимо сделать некоторые дискретные математические преобразования, чтобы создать подпись. Используя все эти параметры, которые до сих пор были получены. Поскольку мы работаем с зашифрованными данными, подпись также будет зашифрована.
Первое, что нужно сделать, - это запустить механизм расшифровки порога, чтобы все участники расшифровали параметр $w$ и присвоили это значение $\eta$:
 
$\eta=TDec(w)=kp mod q$ - все участники одновременно дешифруют $w$
 
Далее вычисляется параметр $\Psi$, который является мультипликативным обратным к $\eta$ по модулю $q$ , а $q$ - это мощность всего эллиптической кривой по времени:
 
$\Psi=n^{-1}mod q = k^{-1}p^{-1}$
 
Затем, имея $m$ , который является хэшем сообщения, которое мы подписываем (или хэш транзакции), производится оценка подписи с помощью следующего уравнения:
 
$\sigma=\Psi\times _e[(m\times _eu)+_eE(r\times_ev)]$
 
$c$ - значение, которое мы только что оценили, а $u$ , $r$ и $v$ - параметры, совместно оцененные всеми подписавшими сторонами в предыдущих раундах.
Итак, поскольку $u$ является зашифрованным $r$ , а $v$ является зашифрованным $ρ$, умноженным на секретный ключ $ECDSA$, мы можем выполнить следующее преобразование:
 
$\sigma=\psi\times_e[E(mp)+_eE(rpx)]$
 
И если мы заменим $\Psi$ значением, которое оно представляет, мы получим следующее уравнение:
 
$\sigma=(k^{-1}p^{-1})\times_e[E(mp)+eE(rpx)]$
 
И, наконец, если мы исключим $ρ$, мы получим это:
 
$\sigma=E(k^{-1}(m+xr))$
 
А это есть ни что иное, как уравнение для стандартной сигнатуры $ECDSA$, где $k$- криптографически безопасное случайное целое число, $m$ - хеш сообщения, $x$ - наш секретный ключ $ECDSA$, а $r$ - точка, сгенерированная кривой умноженное в $k$ раз по модулю $q$. Так что это уравнение для стандартного протокола $ECDSA$.
 
Так как все уравнения были сделаны на шифротекстах, то и результирующая подпись будет зашифрована:
 
$\sigma=E(s)$

 

6. Теперь необходимо использовать механизм расшифровки пароля, чтобы узнать значение $s$. И расшифрованное значение $s$ и полученное в 4 раунде значение $r$, вместе составляют подпись.