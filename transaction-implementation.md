## Предложения по реализации модуля транзакций в EVEN Network

*24 апреля 2019 г.
EVEN Foundations*

### Содержание

Предложения по программной реализации на языке Go прототипа модуля транзакций в *EVEN Network*.

### Цели

1. Прояснить назначение модуля транзакций в контексте основной ноды (мастер-ноды) *EVEN Network*.

1. Перечислить разновидности транзакций.

1. Представить прототип конкретной программной реализации структур транзакций.

1. Определить формат файла транзакции.

1. Представить прототип `API` для создания (сборки), чтения (парсинга), анализа и верификации (валидации) транзакций.

1. Представить прототип интерфейса командной строки (`CLI`) для работы с транзакциями.

### Спецификации

Модуль транзакций разрабатывается в составе проекта мастер-ноды *EVEN Network*: [github.com/evenfound/even-go/node](http://github.com/evenfound/even-go/node). Его программный код содержится в пакете `transaction`.

#### Назначение модуля транзакций

Модуль транзакций реализует создание (сборку), чтение (парсинг), анализ и верификацию (валидацию) транзакций в контексте *EVEN Network*. Каждая транзакция после своего создания сохраняется в отдельный файл в `IPFS`. Хеш этого файла (адрес `IPFS`) является уникальным идентификатором транзакции.

#### Типы транзакций

| Id   | Тип                  | Комментарий |
|------|----------------------|-------------|
| 0x01 | Мета                 | Value == 0  |
| 0x02 | Выходная             | Value > 0   |
| 0x03 | Входная spend        | Value < 0   |
| 0x04 | Входная change       | Value > 0   |
| 0x05 | Публикация контракта | Value == 0  |
| 0x06 | Вызов контракта      | Value >= 0  |

#### Программная структура транзакции

Транзакция в Go-коде проекта представляется структурой:

```Go
hash Hash // Уникальный хеш (адрес объекта IPFS) 
type transaction struct {
    ID        id        // Тип транзакции и версия формата
    Address   address   // Адрес счета получателя или отправителя
    Message   message   // Подпись приватным ключом счета хеша Trunk
    Source    Hash      // Адрес смарт-контракта или другого ресурса
    Value     value     // Сумма отправления
    Data      data      // Бинарная "полезная нагрузка"
    Timestamp timestamp // Временная метка
    Trunk     Hash      // Адрес последнего проверенного пакета
    Branch    twigs     // Коллекция ссылок на транзакции-кандидаты
    Tag       string    // Информационное поле
}
```

Типы полей структуры:
```Go
type hash      string
type id        [2]byte 
type address   string
type message   string
type value     int64
type data      []byte
type timestamp time.Time
type twig      struct{hash, proof}
type twigs     []twig
```

#### Формат файла транзакции

Формат файла транзакции может быть любым, но существует ограничение, определяемое выбором хранилища: размер файла не должен превышать размер блока `IPFS` (262158 байт). Отсюда следует, что разумным выбором типа формата будет бинарный как более компактный по сравнению с текстовыми форматами.

`XML` не рассматривался — избыточно сложен и неоптимален по размеру.

Стандартная библиотека Go (пакет encoding) предоставляет несколько форматов сериализации структур, в том числе таких бинарных, как `ASN.1` и `GOB` (остальные бинарные форматы оттуда имеют ограниченное применение). Кроме того, существуют сторонние библиотеки сериализации, реализующие, например, `UBJSON` — бинарный вариант `JSON`, `CBOR` (Concise Binary Object Representation), или `Protobuf` — сериализатор для `gRPC`. 

`ASN.1` чрезвычайно сложен. 

`GOB` нестандартен (реализован только в Go и не имеет общепринятого человекочитаемого представления, полезного при отладке) и добавляет избыточную информацию (схему данных), увеличивающую размер. 

`Protobuf` ориентирован на обмен сообщениями и требует внешнего описания структур, что менее удобно, чем сериализация прямо из Go-структуры. 

`UBJSON` эффективен по размеру только при сохранении нестроковых данных, тогда как транзакция состоит в основном из строковых полей.

`CBOR` — примерно аналогичен `UBJSON`.

Остаётся вариант сериализации в обычный текстовый `JSON` с последующим сжатием (zip), что добавляет лишний шаг при конвертации, но является наиболее эффективным по размеру.

Сравнение размеров файлов для некоторых форматов. Генерировалась тестовая непустая транзакция с несколькими twigs:

| Формат | Размер файла транзакции (байты) |
| ------ | ------------------------------- |
| ZJSON | 382 |
| UBJSON | 645 |
| JSON | 653 |
| GOB | 699 |

#### API

Поскольку транзакция является довольно сложной структурой, для её сборки целесообразно применить паттерн Builder. Тогда создание транзакции может выглядеть примерно так:

```Go
builder := transaction.NewBuilderOutput("PAY", 100)
builder.SetAddress("msnxVmXXoTxVP5DNerVbiJ31AP6...").
	SetMessage("30440220790fc006bb8321354456b8...").
	SetSource("myPH9LjpgV8TEKCm7pmqRnhLXmd7JPUoCn").
	SetTrunk("QmTfCejgo2wTwqnDJs8Lu1pCNeCrCDuE4GA...").
	AddTwig("m111111111111111111111111111111").
	AddTwig("m222222222222222222222222222222").
	AddTwig("m333333333333333333333333333333").
	AddTwig("m333333333333333333333333333333")
hash, err := builder.Save() // Готовая транзакция сохранена в IPFS
```

Создание инициирующей транзакции намного проще:

```Go
builder := transaction.NewBuilderMeta("NEW_REG")
builder.SetAddress("msmVvDBcboE8HG7RYeaKHFXcXuorzazCJ8")
hash, err := builder.Save() // Готовая транзакция сохранена в IPFS
```

#### CLI

Утилита `evenctl` предоставляет интерфейс командной строки для работы с транзакциями. Для этого предназначено семейство команд `evenctl wallet tx`:

```
evenctl wallet tx newreg   // создаёт инициирующую транзакцию
evenctl wallet tx pay      // создаёт платёжную транзакцию
evenctl wallet tx contract // создаёт транзакцию, публикующую SC
evenctl wallet tx invoke   // создаёт транзакцию, вызывающую SC
```
