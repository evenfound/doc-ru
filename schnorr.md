## Агрегированная подпись Schnorr с валидацией ECDSA.

Сила _ECDSA _заключается в том, чтобы доказать, что полученный фрагмент данных может быть получен только от пользователя, который имеет закрытый ключ к используемому открытому ключу. Иными словами, владелец закрытого ключа может легко создавать действительные подписи, а все остальные могут легко проверить подпись с помощью открытого ключа, созданного из этого закрытого ключа, даже не зная закрытого ключа.

Формальная математика, стоящая за подписанием и проверкой с помощью _ECDSA_, может быть найдена в [3] , но основной алгоритм состоит в следующем, предполагая циклическую группу _T_, простой порядок _p_ и точку генератора_ G_ в _T_:

Подпись:

1. Формируем ключевую пару приватный/публичный ключ $(x,  P)$, где $P = xG$;
1. Выбираем случайное число $r$ из диапазона генератора;
2. Вычисляем $R = rG$;
3. Выбираем сообщение $z$;
4. Рассчитываем $s = (z + Rx) / r$;
5. Подпись $(R, s)$ готова;

Проверка:

1. Получаем подпись $(R, s)$;
2. Рассчитываем $u=z/s$;
3. Рассчитываем $v=R/s$;
4. Если равенство $rG = uG + vP$ истинно, то подпись верна.

Подпись _ECDSA_ прекрасно работает. К сожалению, он использует _разделение полей_ , что является сложным в вычислительном отношении, и его использование для мультиподписей требует подписи и проверки каждого участника транзакции с несколькими подписями.

Подписи Шнорра[5] были впервые созданы _К.П. Шнорром_ в 1989 году. Затем он запатентовал алгоритм подписи. Срок действия патента истек в 2008 году, и, вероятно, именно поэтому _Сатоши Накамото_ использовал в Bitcoin _ECDSA_ вместо _Schnorr_. Алгоритм подписи Шнорра устраняет дорогостоящее деление полей _ECDSA_ и заменяет его _хэшированием_. Полное математическое доказательство можно найти в [5] .

Подпись:

1. Формируем ключевую пару приватный / публичный ключ $(x,  P)$, где $P = xG$;
2. Выбираем случайное число $r$ из диапазона генератора;
3. Вычисляем $R = rG$;
4. Выбираем сообщение $z$;
5. Вычисляем новую переменную $c = H (P, R, z)$;
6. Рассчитываем $s = r + cx$;
7. Подпись $(R, s)$ готова;

Проверка:

1. Получаем подпись $(R, s)$;
2. Если равенство $sG = R + cP$, где $c = H(P, R, z)$ - истинно, то подпись верна;

В [4] _Питер Уилле_ кратко описывает схемы с несколькими подписями:

>_“Схема мульти-подпись представляет собой комбинацию алгоритма подписи и проверки, где несколько подписантов (каждый со своей ключевой парой) совместно подписывают одно сообщение, в результате чего получают одну подпись. Эта единственная подпись может быть проверена любым, кто знает сообщение и открытые ключи подписывающих лиц. Обратите внимание, что в контексте Биткойна термин «мультисигнал» обычно относится к политике $k$ - из - $n$ , где $k$ может отличаться от $n$ . В криптографической литературе мульти-подписи действительно относятся только к политикам $n$-из-$n$ , хотя   мы можем легко построить $k$-из-$n$ поверх  $n$-из-$n$“._


Как упоминалось ранее, мульти-подписи для _ECDSA_ просты, но не эффективны и не имеют никакой конфиденциальности для тех, кто участвует в транзакции с несколькими сигнатурами: публичный ключ каждого участника открыт.

Шнорр меняет правила игры на мульти-подписи. _Schnorr_ позволяет использовать собственную мульти-подпись благодаря использованию алгоритма хеширования вместо деления поля. Та же самая математика, приведенная выше, работает для группы из $n$ участников транзакции, каждый из которых имеет свою собственную ключевую пару. Есть только несколько изменений в уравнении подписи выше:

1. $X=\sum\limits_{i=0}^NP_i$ - сумма публичных ключей всех участников подписи;
2. Каждый участник выбирает свой уникальный $r_i$ и вычисляет свой уникальный R_i=r_iG, а $R_\Sigma$ является суммой всех $R_i$;
3. Далее, каждый подписант должен вычислить свой собственный $s_i=r_i+c_ix_i$, а $S_\Sigma$ - это сумма всех;
4. Сигнатура теперь является суммой всех уникальных $R$ и всех уникальных $s$, дающих сигнатуру $(R_\Sigma,S_\Sigma)$;
5. Проверка идентична одной транзакции, за исключением того, что публичный ключ $P$ заменяется суммированием всех $P, X$.
6. Если истинно равенство $S_\Sigma G=R_\Sigma+c_iX_i$,  где $c_i=H(X_i,R_i,z)$, то подпись верна.

Проверка нескольких подписей _Schnorr_ аналогична проверке единственной подписи _Schnorr_, заменяющей $P$ на $X$, поэтому проверка не требует знания отдельных открытых ключей, только совокупного открытого ключа.

Теперь очевидно, почему у _Schnorr_ есть встроенная функция мульти-подписи. Для проверки алгоритма подписи просто берется ОДНА подпись $(R_\Sigma,S_\Sigma)$. Невозможно узнать, является ли эта подпись одним или несколькими лицами - это выглядит одинаково. Эта функция известна как агрегация подписи.

К сожалению, существует легкая атака на схему множественных подписей _Schnorr_. _Питер Уилле_ [4] объясняет:

>_“У Алисы есть пара ключей (xA, XA), а у Боба (xB, XB) . Однако ничто не мешает Бобу утверждать, что его открытый ключ XB' = XB - XA . Если он это сделает, другие будут предполагать, что XA + XB' - это агрегированный ключ, с которым Алисе и Бобу нужно взаимодействовать, чтобы подписаться. К сожалению, эта сумма равна XB , и Боб может четко подписать это сам.”_

Это означает, что необходимо использовать решение, которое позволит продолжать использовать агрегацию сигнатур, но исключит эту атаку.

Алгоритм подписи _Bellare-Neven (BN)_ был предложен, чтобы остановить эту атаку. Это адаптация сигнатуры Шнорра, где вводится новая переменная, _L_- хэш публичного ключа каждого участника. Но в то время как _BN_ устраняет атаку, осуществляемую несколькими подписями с использованием сигнатур Шнорра, она просто вновь вводит проблему, которая была в _ECDSA_: _проверяющему нужно снова знать публичный ключ каждого участника_. Теперь мы теряем преимущества конфиденциальности, которые мы достигли с помощью подписей _Schnorr_, поэтому _BN _работать не будет.

_Грег Максвелл_, _Эндрю Поэльстра, Янник Сёрин_ и _Питер Уилле_ придумали решение [4], позволяющее сохранить агрегацию сигнатур и исключить атаку, которую ввели наивные сигнатуры Шнорра. Они назвали его _MuSig_, и он основывается как на _Schnorr_, так и на _BN_.

Подпись:

1. $L_i=H(P_i)$- хэш публичного ключа каждого участника;
2. Вводится переменная $X=\sum\limits_{i=0}^NH(L_i,P_i,)P_i$;
3. Каждый подписант вычисляет свой уникальный $r_i$ и вычисляет свой уникальный $R_i=r_iG$, а $R_\Sigma=\sum\limits_{i=0}^NR_i$ - сумма  всех $R_i$;
4. $c$ также меняется от уравнения _BN_. $c_i=H(X,R_\Sigma,z)\alpha$. Введена новая переменная $\alpha$, где каждый участник использует свой уникальный открытый ключ для вычисления $\alpha=H(L_i,P_i)$. Таким образом, $c_i=H(X,R_\Sigma,z)H(L_i,P_i)$;
5. Каждый участник теперь должен вычислить свой собственный $s_i=r_i+c_ix_i$, а $S_\Sigma=\sum\limits_{i=0}^Ns_i$ - это сумма всех $s_i$;
6. Сигнатура теперь является суммой всех уникальных $R$ и всех уникальных $s$, дающих сигнатуру $(R_\Sigma,S_\Sigma)$.

Проверка:

1. Получаем подпись $(R_\Sigma,S_\Sigma)$;
2. Если действительно равенство $S_\Sigma=R_\Sigma+c_iX$, где $c_i=H(X,R_\Sigma,z)$ - подпись верна.

Мы возобновили агрегирование подписи, поскольку алгоритм проверки не требует открытого ключа отдельного участника $P_i$, а вместо этого требует только суммирования всех $P_i - X$. Это означает, что транзакция с одной подписью будет выглядеть точно так же, как и транзакция с несколькими подписями участников. Это дает гораздо большее увеличение конфиденциальности.

Но, что еще важнее, _MuSig_ ввел ключевое агрегирование, которое устраняет уязвимость обобщенных сигнатур Шнорра. Поскольку $X$ теперь является суммой хэша $L_i$ и их открытого ключа $P_i$, умноженного на $P_i$, теперь нам нужен только один открытый ключ для транзакций с несколькими подписями. Узлы не смогут видеть различные открытые ключи $P_i$, которые составляют значение $X$.
_MuSig_ приводит к собственным и частным транзакциям с несколькими подписями с агрегацией сигнатур - только одна подпись  $(R_\Sigma,S_\Sigma)$, и агрегацией ключей:  только с одним $X$ для представления «публичного ключа» группы - для создания и проверки транзакций.

Преимущества _MuSig _многочисленны:

1. Данные подписи для транзакций с несколькими подписями могут быть большими и громоздкими. _MuSig _позволит пользователям создавать более сложные транзакции, не обременяя сеть и не раскрывая компрометирующую информацию;
2. Сегодня более эффективен, чем отдельные транзакции _ECDSA_, поэтому это должно облегчить работу новых и существующих узлов;
3. Это также означает, что это должно создать больше места в каждом блоке и, следовательно, снизить комиссию за транзакцию.
4. Стимулирует использование других инструментов конфиденциальности, таких как _coinjoin_.

Все это красиво выглядит но в настоящее время практически ни в одной сети без адаптации не применимо. 

Обратим внимание на процесс верификации подписей. 

Если в большинстве сетей, использующих алгоритм верификации подписи _ECDSA _верификация подписи $(R,s)$ с публичным ключом $P$ выглядит как:

$$rG=uG+vP\tag{1}$$ где $u=z/s$ и $v={R}/{s}$


То в версии _MuSig_- по другому:
$$S_\Sigma G=R_\Sigma+c_iX\tag{2}$$ где $c_i=H(X,R_\Sigma,z)$
что позволяет предположить, что валидация сообщений практически во всех сетях, использующих подпись _ECDSA_, будет сомнительной. 

Для того, чтобы валидация по алгоритму _MuSig _была применима в сетях с валидацией _ECDSA_ предлагается использовать следующий метод верификации подписи.

Первым делом нужно провести анализ переменных обоих уравнений  и попробовать определить их подобие:

1. Переменная $G$, на самом деле, является константой общей для обоих;
2. Переменные $s$ из (1) - это аналог $S_\Sigma$из (2), $R$ из (1) - это аналог $R\Sigma$ из (2);
3. Учесть $r$ из (1) можно заменив запись $rG$ на $R$, которую в свою очередь можно представить как $R_\Sigma$;
4. $z$ из (1) - это $c_i$ из (2);
5. Из приведенные в (1) переменных, неясно как с использованием мультиподиси _Schnorr_ будет учитываться значение $P#;

Из приведенных наблюдений видно, что практически все переменные, используемый в транзакции для подписи идентичны и вычислимы, за исключением _P_, которой нет, как таковой в (2) и которая вообще в ней нежелательна, так как дискредитирует подписанта. Попытаемся выразить _P_ через равенство следующего вида, при условии что $rG$ из (1) - это $R_\Sigma$ из (2):
$$\frac{c_i}{S_\Sigma}G+\frac{R_\Sigma}{S_\Sigma}P=S_\Sigma G-c_iX\tag{3}$$

Далее, путем несложных преобразований, получаем:

$$P=R_\Sigma ^{-1}(S_\Sigma ^2 G-S\Sigma c_iX - c_iG)\tag{4}$$
После подстановки  $P$, полученного в (4) в (1) и с учетом подобия переменных, равенство верно:
$$ \frac{c_i}{S_\Sigma}G+\frac{R_\Sigma}{S_\Sigma}R_\Sigma ^{-1}(S_\Sigma ^2-S_\Sigma c_iX - c_iG)=S_\Sigma G-c_iX\tag{5}$$
Учитывая высокие требования к производительности вычислений и учитывая тот факт, что часть переменных не являются волатильными каждую транзакцию, часть из них, для ускорения расчетов, можно объединить и вычислять заранее.

Эксперименты в тестовым сетях сетей, использующих _ECDSA_ на основе кривой _secp256k1_ показали работоспособность предложенного метода при сохранении основных преимуществ _MuSig_ с не существенными потерями по скорости обработки.

[3] [Wikipedia, _Elliptic Curve Digital Signature Algorithm](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)
[4]  [Pieter Wuille, _Key Aggregation for Schnorr Signatures, January 23, 2018](https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures/)
[5] [Wikipedia](https://en.wikipedia.org/wiki/Schnorr_signature)